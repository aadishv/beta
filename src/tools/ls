icp/AlgorithmParameters.tsx
---
// src/tools/icp/AlgorithmParameters.tsx
import React from "react";
import { Slider } from "@/components/ui/slider";
import { Button } from "@/components/ui/button";
import { Copy, ClipboardCheck, Trash2, RotateCcw, PenLine } from "lucide-react";

interface AlgorithmParametersProps {
  sourcePixelSpacing: number;
  setSourcePixelSpacing: React.Dispatch<React.SetStateAction<number>>;
  targetPixelSpacing: number;
  setTargetPixelSpacing: React.Dispatch<React.SetStateAction<number>>;
  maxIterations: number;
  setMaxIterations: React.Dispatch<React.SetStateAction<number>>;
  showCorrespondences: boolean;
  setShowCorrespondences: React.Dispatch<React.SetStateAction<boolean>>;
  activeIndex: number;
  setActiveIndex: React.Dispatch<React.SetStateAction<number>>;
  clearCurve: () => void;
  clearAll: () => void;
  runICP: () => void;
  curves: { points: { x: number; y: number }[]; color: string }[];
  importFromClipboard: (curveIndex: 0 | 1) => void;
  copyToClipboard: (points: { x: number; y: number }[]) => void;
}

const AlgorithmParameters: React.FC<AlgorithmParametersProps> = ({
  sourcePixelSpacing,
  setSourcePixelSpacing,
  targetPixelSpacing,
  setTargetPixelSpacing,
  maxIterations,
  setMaxIterations,
  showCorrespondences,
  setShowCorrespondences,
  activeIndex,
  setActiveIndex,
  clearCurve,
  clearAll,
  runICP,
  curves,
  importFromClipboard,
  copyToClipboard,
}) => {
  return (
    <div className="flex flex-wrap items-end gap-4 mb-4 w-full">
      {/* Curve selection */}
      <div className="flex flex-row items-center gap-2">
        <span className="font-medium pr-2">Curve:</span>
        <Button
          variant={activeIndex === 0 ? "default" : "outline"}
          onClick={() => setActiveIndex(0)}
          size="sm"
          className="flex items-center gap-2"
        >
          <div className="w-3 h-3 rounded-full bg-blue-500" />
          Source
        </Button>
        <Button
          variant={activeIndex === 1 ? "default" : "outline"}
          onClick={() => setActiveIndex(1)}
          size="sm"
          className="flex items-center gap-2"
        >
          <div className="w-3 h-3 rounded-full bg-red-500" />
          Target
        </Button>
      </div>

      {/* Source Pixel Spacing */}
      <div className="flex flex-col items-start gap-2 min-w-[180px]">
        <label className="text-sm font-medium">Source Spacing: {sourcePixelSpacing}px</label>
        <Slider
          value={[sourcePixelSpacing]}
          min={2}
          max={50}
          step={1}
          onValueChange={(value) => setSourcePixelSpacing(value[0])}
        />
      </div>

      {/* Target Pixel Spacing */}
      <div className="flex flex-col items-start gap-2 min-w-[180px]">
        <label className="text-sm font-medium">Target Spacing: {targetPixelSpacing}px</label>
        <Slider
          value={[targetPixelSpacing]}
          min={2}
          max={50}
          step={1}
          onValueChange={(value) => setTargetPixelSpacing(value[0])}
        />
      </div>

      {/* Max Iterations */}
      <div className="flex flex-col items-start gap-2 min-w-[150px]">
        <label className="text-sm font-medium">Max Iterations: {maxIterations}</label>
        <Slider
          value={[maxIterations]}
          min={5}
          max={50}
          step={1}
          onValueChange={(value) => setMaxIterations(value[0])}
        />
      </div>

      {/* Show Correspondences */}
      <div className="flex flex-col items-start gap-2 min-w-[120px]">
        <label className="text-sm font-medium">Options</label>
        <div className="flex items-center space-x-2">
          <input
            type="checkbox"
            id="show-correspondences"
            checked={showCorrespondences}
            onChange={(e) => setShowCorrespondences(e.target.checked)}
            className="rounded border-gray-300 text-primary focus:ring-primary"
          />
          <label htmlFor="show-correspondences" className="text-sm font-medium">
            Show Lines
          </label>
        </div>
      </div>

      {/* Action Buttons */}
      <div className="flex flex-col items-start gap-2 min-w-[320px] flex-1">
        <label className="text-sm font-medium">Actions</label>
        <div className="flex flex-wrap gap-2">
          <Button variant="outline" size="sm" onClick={clearCurve} className="flex items-center gap-2">
            <Trash2 className="h-4 w-4" />
            Clear Current
          </Button>
          <Button variant="outline" size="sm" onClick={clearAll} className="flex items-center gap-2">
            <RotateCcw className="h-4 w-4" />
            Clear All
          </Button>
          <Button
            onClick={runICP}
            className="flex items-center gap-2"
            size="sm"
            disabled={curves[0].points.length < 2 || curves[1].points.length < 2}
          >
            <PenLine className="h-4 w-4" />
            Run ICP
          </Button>
          <Button variant="outline" size="sm" onClick={() => copyToClipboard(curves[0].points)} className="flex items-center gap-2">
            <Copy className="h-4 w-4" />
            Copy Source
          </Button>
          <Button variant="outline" size="sm" onClick={() => importFromClipboard(0)} className="flex items-center gap-2">
            <ClipboardCheck className="h-4 w-4" />
            Import Source
          </Button>
          <Button variant="outline" size="sm" onClick={() => copyToClipboard(curves[1].points)} className="flex items-center gap-2">
            <Copy className="h-4 w-4" />
            Copy Target
          </Button>
          <Button variant="outline" size="sm" onClick={() => importFromClipboard(1)} className="flex items-center gap-2">
            <ClipboardCheck className="h-4 w-4" />
            Import Target
          </Button>
        </div>
      </div>
    </div>
  );
};

export default AlgorithmParameters;


---
icp/AnimationControls.tsx
---
// src/tools/icp/AnimationControls.tsx
import React, { useEffect, useRef } from "react";
import { Button } from "@/components/ui/button";
import { Play, Pause, RotateCcw, StepForward, StepBack } from "lucide-react";
import { Slider } from "@/components/ui/slider";

interface AnimationControlsProps {
  icpStates: any[]; // TODO: Replace any with the correct type
  currentStep: number;
  isRunning: boolean;
  setIsRunning: React.Dispatch<React.SetStateAction<boolean>>;
  setCurrentStep: React.Dispatch<React.SetStateAction<number>>;
}

const AnimationControls: React.FC<AnimationControlsProps> = ({
  icpStates,
  currentStep,
  isRunning,
  setIsRunning,
  setCurrentStep,
}) => {
  const animationRef = useRef<number | null>(null);

  // Animation controls with faster playback and correct play/pause logic
  const startAnimation = () => {
    stopAnimation();
    setIsRunning(true);

    let frame = currentStep;

    const animate = () => {
      frame += 1;
      setCurrentStep((prev) => {
        if (prev >= icpStates.length - 1) {
          setIsRunning(false);
          return prev;
        }
        return prev + 1;
      });

      if (frame < icpStates.length - 1) {
        // Faster playback: 60ms per frame
        animationRef.current = window.setTimeout(animate, 60) as unknown as number;
      } else {
        setIsRunning(false);
      }
    };

    if (frame < icpStates.length - 1) {
      animationRef.current = window.setTimeout(animate, 60) as unknown as number;
    }
  };

  const stopAnimation = () => {
    if (animationRef.current !== null) {
      clearTimeout(animationRef.current);
      animationRef.current = null;
    }
    setIsRunning(false);
  };

  // Improved step functions
  const stepForward = () => {
    stopAnimation();
    setCurrentStep((prev) => Math.min(prev + 1, icpStates.length - 1));
  };

  const stepBack = () => {
    stopAnimation();
    setCurrentStep((prev) => Math.max(prev - 1, 0));
  };

  const resetAnimation = () => {
    stopAnimation();
    setCurrentStep(0);
  };

  useEffect(() => {
    if (isRunning && icpStates.length > 0) {
      if (currentStep < icpStates.length - 1) {
        startAnimation();
      } else {
        setIsRunning(false);
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isRunning, icpStates, currentStep]);

  return (
    <>
      {icpStates.length > 0 && (
        <div className="space-y-4">
          <div className="flex justify-between items-center">
            <h3 className="font-medium">Iteration Progress</h3>
            <span className="text-sm text-muted-foreground">
              {currentStep + 1} / {icpStates.length}
            </span>
          </div>

          <Slider
            value={[currentStep]}
            min={0}
            max={icpStates.length - 1}
            step={1}
            onValueChange={(value) => {
              stopAnimation();
              setCurrentStep(value[0]);
            }}
          />

          <div className="flex justify-center space-x-2">
            <Button variant="outline" size="icon" onClick={resetAnimation} disabled={icpStates.length === 0}>
              <RotateCcw className="h-4 w-4" />
            </Button>
            <Button
              variant="outline"
              size="icon"
              onClick={stepBack}
              disabled={currentStep === 0 || icpStates.length === 0}
            >
              <StepBack className="h-4 w-4" />
            </Button>
            <Button
              variant={isRunning ? "destructive" : "default"}
              size="icon"
              onClick={isRunning ? stopAnimation : startAnimation}
              disabled={icpStates.length === 0}
            >
              {isRunning ? <Pause className="h-4 w-4" /> : <Play className="h-4 w-4" />}
            </Button>
            <Button
              variant="outline"
              size="icon"
              onClick={stepForward}
              disabled={currentStep === icpStates.length - 1 || icpStates.length === 0}
            >
              <StepForward className="h-4 w-4" />
            </Button>
          </div>
        </div>
      )}
    </>
  );
};

export default AnimationControls;


---
icp/App.tsx
---
// App.tsx
import React from 'react';
import ICPVisualization from './ICPVisualization';

export default function App() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-between p-4 md:p-8">
      <div className="w-full max-w-5xl">
        <h1 className="text-3xl font-bold mb-4">Iterative Closest Point Algorithm Visualization</h1>
        <p className="mb-6 text-muted-foreground">
          Draw two separate curves and see how the ICP algorithm aligns them. Use the controls to step through each
          iteration.
        </p>
        <ICPVisualization />
      </div>
    </main>
  );
}


---
icp/Canvas.tsx
---
// src/tools/icp-visualization/Canvas.tsx

import React, { useEffect, useRef } from "react";
import type { Point, Curve, ICPState } from "./types";

interface CanvasProps {
  curves: Curve[];
  activeIndex: number;
  isDrawing: boolean;
  setIsDrawing: React.Dispatch<React.SetStateAction<boolean>>;
  setCurves: React.Dispatch<React.SetStateAction<Curve[]>>;
  setActiveIndex: React.Dispatch<React.SetStateAction<number>>;
  canvasRef: React.RefObject<HTMLCanvasElement>;
  canvasContainerRef: React.RefObject<HTMLDivElement>;
  icpStates: ICPState[];
  currentStep: number;
  sourcePixelSpacing: number;
  targetPixelSpacing: number;
  showCorrespondences: boolean;
  setIcpStates: React.Dispatch<React.SetStateAction<ICPState[]>>;
  setCurrentStep: React.Dispatch<React.SetStateAction<number>>;
  transformMode: 'none' | 'translate' | 'rotate';
  transformCurveIndex: 0 | 1;
}

import { samplePoints, calculateCentroid } from "./utils";

const Canvas: React.FC<CanvasProps> = ({
  curves,
  activeIndex,
  isDrawing,
  setIsDrawing,
  setCurves,
  setActiveIndex,
  canvasRef,
  canvasContainerRef,
  icpStates,
  currentStep,
  sourcePixelSpacing,
  targetPixelSpacing,
  showCorrespondences,
  setIcpStates,
  setCurrentStep,
  transformMode,
  transformCurveIndex,
}) => {
  const isTransitioning = useRef(false);

  // Drag state for transform
  const dragStart = useRef<{ x: number, y: number } | null>(null);
  const originalPoints = useRef<Point[] | null>(null);
  const rotationStartAngle = useRef<number | null>(null);
  const centroid = useRef<Point | null>(null);

  // Initialize canvas size on mount and window resize
  useEffect(() => {
    const updateCanvasSize = () => {
      if (!canvasRef.current || !canvasContainerRef.current) return;

      const container = canvasContainerRef.current;
      const canvas = canvasRef.current;

      // Get the container's dimensions
      const rect = container.getBoundingClientRect();

      // Make the canvas square: use the smaller of width/height
      const size = Math.min(rect.width, rect.height);

      // Account for device pixel ratio
      const dpr = window.devicePixelRatio || 1;
      canvas.width = size * dpr;
      canvas.height = size * dpr;

      // Set CSS size (keeps layout correct)
      canvas.style.width = `${size}px`;
      canvas.style.height = `${size}px`;

      // Scale the context so drawing operations are crisp
      const ctx = canvas.getContext("2d");
      if (ctx) {
        ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset any existing transforms
        ctx.scale(dpr, dpr); // Scale for device pixel ratio
      }

      // Redraw canvas after resize
      drawCanvas();
    };

    // Initial setup
    updateCanvasSize();

    // Add resize listener
    window.addEventListener("resize", updateCanvasSize);

    return () => {
      window.removeEventListener("resize", updateCanvasSize);
    };
  }, []);

  // Update canvas when relevant state changes
  useEffect(() => {
    drawCanvas();
  }, [curves, icpStates, currentStep, sourcePixelSpacing, targetPixelSpacing, showCorrespondences]);

  // Safety mechanism to ensure isTransitioning doesn't get stuck
  useEffect(() => {
    const resetTransitionFlag = () => {
      isTransitioning.current = false;
    };

    // Reset the flag after a short delay to ensure it doesn't get stuck
    const timeoutId = setTimeout(resetTransitionFlag, 100);

    return () => {
      clearTimeout(timeoutId);
    };
  }, [icpStates]); // Only depend on `icpStates` because `currentStep` will rerender it anyway

  // Map mouse coordinates to logical [-80, 80] coordinates
  const getMouseCoordinates = (e: React.MouseEvent<HTMLCanvasElement>): Point => {
    if (!canvasRef.current) return { x: 0, y: 0 };

    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();

    // Get the position within the canvas element in pixels
    const px = (e.clientX - rect.left) * (canvas.width / rect.width);
    const py = (e.clientY - rect.top) * (canvas.height / rect.height);

    // Map to logical coordinates
    const logicalX = (px / canvas.width) * 160 - 80;
    const logicalY = 80 - (py / canvas.height) * 160;
    return { x: logicalX, y: logicalY };
  };

  // Handle mouse events for drawing and transform
  const handleMouseDown = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!canvasRef.current) return;

    if (transformMode === 'none') {
      setIsDrawing(true);
      const point = getMouseCoordinates(e);

      setCurves((prev) => {
        const newCurves = [...prev];
        newCurves[activeIndex] = {
          ...newCurves[activeIndex],
          points: [...newCurves[activeIndex].points, point],
        };
        return newCurves;
      });
      return;
    }

    // Transform mode
    if (transformMode === 'translate' || transformMode === 'rotate') {
      dragStart.current = getMouseCoordinates(e);
      originalPoints.current = curves[transformCurveIndex].points.map(p => ({ ...p }));
      if (transformMode === 'rotate') {
        centroid.current = calculateCentroid(originalPoints.current);
        const start = dragStart.current;
        rotationStartAngle.current = Math.atan2(start.y - centroid.current.y, start.x - centroid.current.x);
      }
      setIsDrawing(true);
    }
  };

  const handleMouseMove = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDrawing || !canvasRef.current) return;

    if (transformMode === 'none') {
      const point = getMouseCoordinates(e);

      setCurves((prev) => {
        const newCurves = [...prev];
        newCurves[activeIndex] = {
          ...newCurves[activeIndex],
          points: [...newCurves[activeIndex].points, point],
        };
        return newCurves;
      });
      return;
    }

    // Transform mode
    if (!dragStart.current || !originalPoints.current) return;
    const current = getMouseCoordinates(e);

    if (transformMode === 'translate') {
      const dx = current.x - dragStart.current.x;
      const dy = current.y - dragStart.current.y;
      setCurves(prev => {
        const newCurves = [...prev];
        newCurves[transformCurveIndex] = {
          ...newCurves[transformCurveIndex],
          points: originalPoints.current!.map(p => ({ x: p.x + dx, y: p.y + dy })),
        };
        return newCurves;
      });
    } else if (transformMode === 'rotate' && centroid.current && rotationStartAngle.current !== null) {
      const angleNow = Math.atan2(current.y - centroid.current.y, current.x - centroid.current.y + centroid.current.x - centroid.current.x);
      // Correction: should be Math.atan2(current.y - centroid.current.y, current.x - centroid.current.x)
      const correctedAngleNow = Math.atan2(current.y - centroid.current.y, current.x - centroid.current.x);
      const deltaAngle = correctedAngleNow - rotationStartAngle.current;
      setCurves(prev => {
        const newCurves = [...prev];
        newCurves[transformCurveIndex] = {
          ...newCurves[transformCurveIndex],
          points: originalPoints.current!.map(p => {
            const dx = p.x - centroid.current!.x;
            const dy = p.y - centroid.current!.y;
            const cos = Math.cos(deltaAngle);
            const sin = Math.sin(deltaAngle);
            return {
              x: centroid.current!.x + cos * dx - sin * dy,
              y: centroid.current!.y + sin * dx + cos * dy,
            };
          }),
        };
        return newCurves;
      });
    }
  };

  const handleMouseUp = () => {
    setIsDrawing(false);
    dragStart.current = null;
    originalPoints.current = null;
    rotationStartAngle.current = null;
    centroid.current = null;
  };

  const handleMouseLeave = () => {
    setIsDrawing(false);
    dragStart.current = null;
    originalPoints.current = null;
    rotationStartAngle.current = null;
    centroid.current = null;
  };

  const clearCurve = () => {
    setCurves((prev) => {
      const newCurves = [...prev];
      newCurves[activeIndex] = { ...newCurves[activeIndex], points: [] };
      return newCurves;
    });
    setIcpStates([]);
    setCurrentStep(0);
  };

  const clearAll = () => {
    setCurves([
      { points: [], color: "#3b82f6" },
      { points: [], color: "#ef4444" },
    ]);
    setIcpStates([]);
    setCurrentStep(0);
  };

  // Map logical [-80, 80] coordinates to canvas pixel coordinates
  const logicalToCanvas = (x: number, y: number, width: number, height: number): { cx: number, cy: number } => {
    const cx = ((x + 80) / 160) * width;
    const cy = height - ((y + 80) / 160) * height;
    return { cx, cy };
  };

  const drawCanvas = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext("2d");
    if (!ctx) return;
    ctx.setTransform(1, 0, 0, 1, 0, 0); // Always reset before drawing

    // Ensure we completely clear the canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Drawing size constants for high-DPI comfort
    const circleRadius = 8;
    const curveLineWidth = 4;
    const transformedCurveLineWidth = 6;
    const correspondenceLineWidth = 2;

    // If we have no ICP states, draw the original curves using fixed logical coordinates
    if (icpStates.length === 0) {
      curves.forEach((curve, index) => {
        if (curve.points.length === 0) return;

        // Draw the curve
        ctx.strokeStyle = curve.color;
        ctx.lineWidth = curveLineWidth;
        ctx.beginPath();
        const { cx: x0, cy: y0 } = logicalToCanvas(curve.points[0].x, curve.points[0].y, canvas.width, canvas.height);
        ctx.moveTo(x0, y0);

        for (let i = 1; i < curve.points.length; i++) {
          const { cx, cy } = logicalToCanvas(curve.points[i].x, curve.points[i].y, canvas.width, canvas.height);
          ctx.lineTo(cx, cy);
        }
        ctx.stroke();

        // Draw the sample points if ICP is ready to run (both curves exist)
        if (curves[0].points.length > 0 && curves[1].points.length > 0) {
          const spacing = index === 0 ? sourcePixelSpacing : targetPixelSpacing;
          const sampledPoints = samplePoints(curve.points, spacing);

          // Draw circles at each sample point
          ctx.fillStyle = curve.color;
          sampledPoints.forEach((point) => {
            const { cx, cy } = logicalToCanvas(point.x, point.y, canvas.width, canvas.height);
            ctx.beginPath();
            ctx.arc(cx, cy, circleRadius, 0, Math.PI * 2);
            ctx.fill();

            // Add white border for better visibility
            ctx.strokeStyle = "white";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cx, cy, circleRadius, 0, Math.PI * 2);
            ctx.stroke();
          });
        }
      });
    }
    // If we have ICP states and are on a valid step, draw the current state
    else if (icpStates.length > 0 && currentStep !== undefined) {
      const state = icpStates[currentStep];
      if (!state) return;

      const { rotation, translation } = state.transformation;

      // Create transformed source curve points by applying the current transformation
      const transformedSourceCurve: Point[] = [];
      if (curves[0].points.length > 0) {
        for (let i = 0; i < curves[0].points.length; i++) {
          // Apply the full accumulated transformation from the current state
          const originalPoint = curves[0].points[i];
          // ICP sometimes performs the rotation around the centroid, so we'll do the same
          const sourceCentroid = calculateCentroid(curves[0].points);

          // 1. Translate to origin based on source centroid
          const dx = originalPoint.x - sourceCentroid.x;
          const dy = originalPoint.y - sourceCentroid.y;

          // 2. Rotate
          const cos = Math.cos(rotation);
          const sin = Math.sin(rotation);
          const rotatedX = cos * dx - sin * dy;
          const rotatedY = sin * dx + cos * dy;

          // 3. Translate back and add the translation component
          const transformedPoint = {
            x: rotatedX + sourceCentroid.x + translation.x,
            y: rotatedY + sourceCentroid.y + translation.y,
          };

          transformedSourceCurve.push(transformedPoint);
        }
      }

      // Draw the target curve (red)
      ctx.strokeStyle = curves[1].color;
      ctx.lineWidth = transformedCurveLineWidth;
      ctx.beginPath();
      if (curves[1].points.length > 0) {
        const { cx: x0, cy: y0 } = logicalToCanvas(curves[1].points[0].x, curves[1].points[0].y, canvas.width, canvas.height);
        ctx.moveTo(x0, y0);

        for (let i = 1; i < curves[1].points.length; i++) {
          const { cx, cy } = logicalToCanvas(curves[1].points[i].x, curves[1].points[i].y, canvas.width, canvas.height);
          ctx.lineTo(cx, cy);
        }
      }
      ctx.stroke();

      // Draw the target sample points
      const targetPoints = state.targetPoints;
      ctx.fillStyle = curves[1].color;
      targetPoints.forEach((point) => {
        const { cx, cy } = logicalToCanvas(point.x, point.y, canvas.width, canvas.height);
        ctx.beginPath();
        ctx.arc(cx, cy, circleRadius, 0, Math.PI * 2);
        ctx.fill();

        // Add white border for better visibility
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx, cy, circleRadius, 0, Math.PI * 2);
        ctx.stroke();
      });

      // Draw the transformed source curve (blue)
      ctx.strokeStyle = curves[0].color;
      ctx.lineWidth = transformedCurveLineWidth;
      ctx.beginPath();

      if (transformedSourceCurve.length > 0) {
        const { cx: x0, cy: y0 } = logicalToCanvas(transformedSourceCurve[0].x, transformedSourceCurve[0].y, canvas.width, canvas.height);
        ctx.moveTo(x0, y0);

        for (let i = 1; i < transformedSourceCurve.length; i++) {
          const { cx, cy } = logicalToCanvas(transformedSourceCurve[i].x, transformedSourceCurve[i].y, canvas.width, canvas.height);
          ctx.lineTo(cx, cy);
        }
      }
      ctx.stroke();

      // Draw the transformed source sample points
      const sourcePoints = state.transformedPoints;
      ctx.fillStyle = curves[0].color;
      sourcePoints.forEach((point) => {
        const { cx, cy } = logicalToCanvas(point.x, point.y, canvas.width, canvas.height);
        ctx.beginPath();
        ctx.arc(cx, cy, circleRadius, 0, Math.PI * 2);
        ctx.fill();

        // Add white border for better visibility
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx, cy, circleRadius, 0, Math.PI * 2);
        ctx.stroke();
      });

      // Draw correspondence lines between points
      if (showCorrespondences && state.correspondences.length > 0) {
        ctx.strokeStyle = "rgba(150, 150, 150, 0.6)";
        ctx.lineWidth = correspondenceLineWidth;
        state.correspondences.forEach(([srcIdx, tgtIdx]) => {
          if (srcIdx < sourcePoints.length && tgtIdx < targetPoints.length) {
            const srcPoint = sourcePoints[srcIdx];
            const tgtPoint = targetPoints[tgtIdx];
            const { cx: srcX, cy: srcY } = logicalToCanvas(srcPoint.x, srcPoint.y, canvas.width, canvas.height);
            const { cx: tgtX, cy: tgtY } = logicalToCanvas(tgtPoint.x, tgtPoint.y, canvas.width, canvas.height);

            ctx.beginPath();
            ctx.moveTo(srcX, srcY);
            ctx.lineTo(tgtX, tgtY);
            ctx.stroke();
          }
        });
      }
    }

    // Mark transition as complete
    isTransitioning.current = false;
  };

  return (
    <div
      ref={canvasContainerRef}
      className="relative border rounded-md overflow-hidden flex items-center justify-center"
      style={{ aspectRatio: "1 / 1", width: "100%", maxWidth: "700px", maxHeight: "700px", minHeight: "400px", margin: "0 auto" }}
    >
      <canvas
        ref={canvasRef}
        className="bg-background cursor-crosshair"
        style={{ display: "block", width: "100%", height: "100%", aspectRatio: "1 / 1" }}
        onMouseDown={handleMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
        onMouseLeave={handleMouseLeave}
      />
    </div>
  );
};

export default Canvas;


---
icp/HowItWorks.tsx
---
// src/tools/icp/HowItWorks.tsx
import React from "react";

const HowItWorks: React.FC = () => {
  return (
    <div className="border rounded-lg p-4 bg-card">
      <h2 className="text-xl font-semibold mb-2">How It Works</h2>
      <p className="text-muted-foreground">
        The Iterative Closest Point (ICP) algorithm aligns two point clouds by finding the optimal transformation
        (rotation and translation) that minimizes the distance between corresponding points. The algorithm follows
        these steps:
      </p>
      <ol className="list-decimal list-inside mt-2 space-y-1 text-muted-foreground">
        <li>Sample points from both curves (with potentially different pixel spacing intervals)</li>
        <li>For each point in the source curve, find the closest point in the target curve</li>
        <li>Calculate the optimal rotation and translation to align the corresponding points</li>
        <li>Apply the transformation to the source points</li>
        <li>Repeat for the specified number of iterations</li>
        <li>Animation speed adapts based on the error reduction (faster animation when error decreases more)</li>
      </ol>
    </div>
  );
};

export default HowItWorks;


---
icp/ICPVisualization.tsx
---
// src/tools/icp/ICPVisualization.tsx
import React, { useRef, useState } from "react";
import { Button } from "@/components/ui/button";
import { Copy, PenLine, RotateCcw, Trash2 } from "lucide-react";
import Canvas from "./Canvas";
import AlgorithmParameters from "./AlgorithmParameters";
import AnimationControls from "./AnimationControls";
import HowItWorks from "./HowItWorks";
import type { ICPState, Curve, Point } from "./types";
import { copyToClipboard } from "./utils";
import { ClipboardCheck } from "lucide-react";
import { samplePoints } from "./utils";
import { runICPAlgorithm } from "./icpAlgorithm"; // Import the ICP algorithm

export function ICPVisualization() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const canvasContainerRef = useRef<HTMLDivElement>(null);
  const [curves, setCurves] = useState<Curve[]>([
    { points: [], color: "#3b82f6" }, // Source curve (blue)
    { points: [], color: "#ef4444" }, // Target curve (red)
  ]);
  const [activeIndex, setActiveIndex] = useState(0);
  const [isDrawing, setIsDrawing] = useState(false);
  const [icpStates, setIcpStates] = useState<ICPState[]>([]);
  const [currentStep, setCurrentStep] = useState(0);
  const [isRunning, setIsRunning] = useState(false);
  const [sourcePixelSpacing, setSourcePixelSpacing] = useState(10);
  const [targetPixelSpacing, setTargetPixelSpacing] = useState(10);
  const [maxIterations, setMaxIterations] = useState(20);
  const [showCorrespondences, setShowCorrespondences] = useState(false);

  // Transform mode and curve selection
  const [transformMode, setTransformMode] = useState<'none' | 'translate' | 'rotate'>('none');
  const [transformCurveIndex, setTransformCurveIndex] = useState<0 | 1>(0);

  const clearCurve = () => {
    setCurves((prev) => {
      const newCurves = [...prev];
      newCurves[activeIndex] = { ...newCurves[activeIndex], points: [] };
      return newCurves;
    });
    setIcpStates([]);
    setCurrentStep(0);
  };

  const clearAll = () => {
    setCurves([
      { points: [], color: "#3b82f6" },
      { points: [], color: "#ef4444" },
    ]);
    setIcpStates([]);
    setCurrentStep(0);
  };

  const runICP = async () => {
    if (curves[0].points.length < 2 || curves[1].points.length < 2) {
      alert("Please draw both curves first");
      return;
    }

    const sourcePoints = samplePoints(curves[0].points, sourcePixelSpacing);
    const targetPoints = samplePoints(curves[1].points, targetPixelSpacing);

    const result = await runICPAlgorithm(sourcePoints, targetPoints, maxIterations);

    setIcpStates(result);
    setCurrentStep(0);
  };

  // Helper to parse clipboard text into points
  const parsePointsFromClipboard = (text: string): Point[] => {
    // Expecting tab-separated values, possibly with a header
    const lines = text.trim().split(/\r?\n/);
    const points: Point[] = [];
    for (const line of lines) {
      if (/^\s*(x\s*\t\s*y|x\s*,\s*y)/i.test(line)) continue; // skip header
      const [x, y] = line.split(/\s*[\t,]\s*/).map(Number);
      if (!isNaN(x) && !isNaN(y)) {
        points.push({ x, y });
      }
    }
    return points;
  };

  // Import from clipboard for source or target
  const importFromClipboard = async (curveIndex: 0 | 1) => {
    try {
      const text = await navigator.clipboard.readText();
      let importedPoints = parsePointsFromClipboard(text);
      if (importedPoints.length > 0) {
        setCurves(prev => {
          const newCurves = [...prev];
          newCurves[curveIndex] = { ...newCurves[curveIndex], points: importedPoints };
          return newCurves;
        });
        setIcpStates([]);
        setCurrentStep(0);
      } else {
        alert("Clipboard does not contain valid points data.");
      }
    } catch (e) {
      alert("Failed to read from clipboard.");
    }
  };

  return (
    <div className="flex flex-col space-y-4">
      {/* Parameters bar */}
      <AlgorithmParameters
        sourcePixelSpacing={sourcePixelSpacing}
        setSourcePixelSpacing={setSourcePixelSpacing}
        targetPixelSpacing={targetPixelSpacing}
        setTargetPixelSpacing={setTargetPixelSpacing}
        maxIterations={maxIterations}
        setMaxIterations={setMaxIterations}
        showCorrespondences={showCorrespondences}
        setShowCorrespondences={setShowCorrespondences}
        activeIndex={activeIndex}
        setActiveIndex={setActiveIndex}
        clearCurve={clearCurve}
        clearAll={clearAll}
        runICP={runICP}
        curves={curves}
        importFromClipboard={importFromClipboard}
        copyToClipboard={copyToClipboard}
      />

      {/* Transform controls */}
      <div className="flex flex-wrap gap-2 mb-4">
        <span className="font-medium">Transform:</span>
        <Button
          variant={transformMode === 'none' ? 'default' : 'outline'}
          onClick={() => setTransformMode('none')}
          size="sm"
        >
          None
        </Button>
        <Button
          variant={transformMode === 'translate' ? 'default' : 'outline'}
          onClick={() => setTransformMode(transformMode === 'translate' ? 'none' : 'translate')}
          size="sm"
        >
          Translate
        </Button>
        <Button
          variant={transformMode === 'rotate' ? 'default' : 'outline'}
          onClick={() => setTransformMode(transformMode === 'rotate' ? 'none' : 'rotate')}
          size="sm"
        >
          Rotate
        </Button>
        <span className="ml-4 font-medium">Curve:</span>
        <Button
          variant={transformCurveIndex === 0 ? 'default' : 'outline'}
          onClick={() => setTransformCurveIndex(0)}
          size="sm"
        >
          Source
        </Button>
        <Button
          variant={transformCurveIndex === 1 ? 'default' : 'outline'}
          onClick={() => setTransformCurveIndex(1)}
          size="sm"
        >
          Target
        </Button>
      </div>

      {/* Canvas */}
      <div className="border rounded-lg p-4 bg-card">
        <Canvas
          curves={curves}
          activeIndex={activeIndex}
          isDrawing={isDrawing}
          setIsDrawing={setIsDrawing}
          setCurves={setCurves}
          setActiveIndex={setActiveIndex}
          canvasRef={canvasRef}
          canvasContainerRef={canvasContainerRef}
          icpStates={icpStates}
          currentStep={currentStep}
          sourcePixelSpacing={sourcePixelSpacing}
          targetPixelSpacing={targetPixelSpacing}
          showCorrespondences={showCorrespondences}
          setIcpStates={setIcpStates}
          setCurrentStep={setCurrentStep}
          transformMode={transformMode}
          transformCurveIndex={transformCurveIndex}
        />
      </div>

      {/* Animation controls */}
      <div className="border rounded-lg p-4 bg-card">
        <AnimationControls
          icpStates={icpStates}
          currentStep={currentStep}
          isRunning={isRunning}
          setIsRunning={setIsRunning}
          setCurrentStep={setCurrentStep}
        />
      </div>

      <HowItWorks />
    </div>
  );
}

export default ICPVisualization;


---
icp/icpAlgorithm.ts
---
// src/tools/icp/icpAlgorithm.ts
import type { Point, ICPState } from "./types";
import { findClosestPoint, calculateCentroid, calculateError } from "./utils";

export const runICPAlgorithm = async (
  sourcePoints: Point[],
  targetPoints: Point[],
  maxIterations: number
): Promise<ICPState[]> => {
  return new Promise((resolve) => {
    // Initialize ICP states
    const states: ICPState[] = [];

    // Initial state - no transformation yet (iteration 0)
    let currentSourcePoints = sourcePoints.map((p) => ({ ...p })); // Deep copy
    let rotation = 0;
    let translation = { x: 0, y: 0 };

    // Add initial state (iteration 0) with no transformation
    states.push({
      sourcePoints: sourcePoints.map((p) => ({ ...p })),
      targetPoints: targetPoints.map((p) => ({ ...p })),
      transformedPoints: currentSourcePoints.map((p) => ({ ...p })),
      correspondences: sourcePoints.map((p, i) => [i, findClosestPoint(p, targetPoints)]),
      transformation: {
        rotation: 0,
        translation: { x: 0, y: 0 },
      },
      error: calculateError(
        sourcePoints,
        sourcePoints.map((p) => targetPoints[findClosestPoint(p, targetPoints)])
      ),
    });

    for (let iter = 0; iter < maxIterations; iter++) {
      // Find correspondences
      const correspondences: [number, number][] = [];
      for (let i = 0; i < currentSourcePoints.length; i++) {
        const closestIdx = findClosestPoint(currentSourcePoints[i], targetPoints);
        correspondences.push([i, closestIdx]);
      }

      // Calculate centroids
      const sourceCentroid = calculateCentroid(currentSourcePoints);
      const targetCentroid = calculateCentroid(
        correspondences.map(([srcIdx, tgtIdx]) => targetPoints[tgtIdx])
      );

      // Calculate optimal rotation
      let numerator = 0;
      let denominator = 0;

      for (let i = 0; i < correspondences.length; i++) {
        const [srcIdx, tgtIdx] = correspondences[i];
        const srcPoint = currentSourcePoints[srcIdx];
        const tgtPoint = targetPoints[tgtIdx];

        const srcDx = srcPoint.x - sourceCentroid.x;
        const srcDy = srcPoint.y - sourceCentroid.y;
        const tgtDx = tgtPoint.x - targetCentroid.x;
        const tgtDy = tgtPoint.y - targetCentroid.y;

        numerator += srcDx * tgtDy - srcDy * tgtDx;
        denominator += srcDx * tgtDx + srcDy * tgtDy;
      }

      const deltaRotation = Math.atan2(numerator, denominator);
      rotation += deltaRotation;

      // Apply rotation to source points (around the centroid)
      const rotatedPoints = currentSourcePoints.map((point) => {
        const cos = Math.cos(deltaRotation);
        const sin = Math.sin(deltaRotation);
        const dx = point.x - sourceCentroid.x;
        const dy = point.y - sourceCentroid.y;

        return {
          x: cos * dx - sin * dy + sourceCentroid.x,
          y: sin * dx + cos * dy + sourceCentroid.y,
        };
      });

      // Calculate translation to align centroids after rotation
      const newSourceCentroid = calculateCentroid(rotatedPoints);
      const deltaTranslation = {
        x: targetCentroid.x - newSourceCentroid.x,
        y: targetCentroid.y - newSourceCentroid.y,
      };

      // Update the accumulated translation
      translation = {
        x: translation.x + deltaTranslation.x,
        y: translation.y + deltaTranslation.y,
      };

      // Apply translation
      currentSourcePoints = rotatedPoints.map((point) => ({
        x: point.x + deltaTranslation.x,
        y: point.y + deltaTranslation.y,
      }));

      // Calculate error
      const error = calculateError(
        currentSourcePoints,
        correspondences.map(([srcIdx, tgtIdx]) => targetPoints[tgtIdx])
      );

      // Save state with the current transformation and deep copies to avoid reference issues
      const prevError = states.length > 0 ? states[states.length - 1].error : error;
      states.push({
        sourcePoints: sourcePoints.map((p) => ({ ...p })),
        targetPoints: targetPoints.map((p) => ({ ...p })),
        transformedPoints: currentSourcePoints.map((p) => ({ ...p })),
        correspondences: [...correspondences],
        transformation: {
          rotation,
          translation: { ...translation },
        },
        error,
        prevError,
      });
    }

    resolve(states);
  });
};


---
icp/types.ts
---
// src/tools/icp/types.ts

export type Point = {
  x: number;
  y: number;
};

export type Curve = {
  points: Point[];
  color: string;
};

export type ICPState = {
  sourcePoints: Point[];
  targetPoints: Point[];
  transformedPoints: Point[];
  correspondences: [number, number][];
  transformation: {
    rotation: number;
    translation: { x: number; y: number };
  };
  error: number;
  prevError?: number;
};


---
icp/utils.ts
---
// src/tools/icp/utils.ts
import type { Point } from "./types";

export function copyToClipboard(data: Point[]) {
  const header = "x\ty\n";
  const csv = data.map(row => `${row.x}\t${row.y}`).join('\n');
  const text = header + csv;
  navigator.clipboard.writeText(text);
}

// Sample points from a curve based on pixel spacing with interpolation
export const samplePoints = (curve: Point[], pixelSpacing: number): Point[] => {
  if (curve.length <= 1) return curve;

  const result: Point[] = [];
  // Always include the first point
  result.push({ ...curve[0] });

  let distanceToNextSample = pixelSpacing;

  // Iterate through each segment of the curve
  for (let i = 1; i < curve.length; i++) {
    const segmentStart = curve[i-1];
    const segmentEnd = curve[i];

    // Calculate segment length
    const segmentLength = Math.sqrt(
      Math.pow(segmentEnd.x - segmentStart.x, 2) +
      Math.pow(segmentEnd.y - segmentStart.y, 2)
    );

    let remainingDistanceInSegment = segmentLength;
    let currentPointX = segmentStart.x;
    let currentPointY = segmentStart.y;

    // Continue sampling points along this segment until we reach its end
    while (remainingDistanceInSegment >= distanceToNextSample) {
      // Calculate how far along the segment the next sample should be
      const ratio = distanceToNextSample / remainingDistanceInSegment;

      // Calculate vector from current point to segment end
      const vectorX = segmentEnd.x - currentPointX;
      const vectorY = segmentEnd.y - currentPointY;

      // Interpolate to find the position
      const newX = currentPointX + ratio * vectorX;
      const newY = currentPointY + ratio * vectorY;

      // Add the interpolated point
      result.push({ x: newX, y: newY });

      // Update current point position
      currentPointX = newX;
      currentPointY = newY;

      // Update remaining distances
      remainingDistanceInSegment -= distanceToNextSample;
      distanceToNextSample = pixelSpacing;
    }

    // Carry over the remaining distance to the next segment
    distanceToNextSample -= remainingDistanceInSegment;
  }

  // Always include the last point if it's not already included
  const lastPoint = curve[curve.length - 1];
  const lastAddedIndex = result.length - 1;

  if (lastAddedIndex >= 0 &&
    (Math.abs(result[lastAddedIndex].x - lastPoint.x) > 0.001 ||
     Math.abs(result[lastAddedIndex].y - lastPoint.y) > 0.001)) {
    result.push({ ...lastPoint });
  }

  return result;
};



// Find closest point
export const findClosestPoint = (point: Point, points: Point[]): number => {
  let minDist = Number.POSITIVE_INFINITY;
  let minIndex = 0;

  for (let i = 0; i < points.length; i++) {
    const dist = Math.sqrt(Math.pow(point.x - points[i].x, 2) + Math.pow(point.y - points[i].y, 2));

    if (dist < minDist) {
      minDist = dist;
      minIndex = i;
    }
  }

  return minIndex;
};

// Calculate centroid of points
export const calculateCentroid = (points: Point[]): Point => {
  if (points.length === 0) return { x: 0, y: 0 };

  const sum = points.reduce((acc, point) => ({ x: acc.x + point.x, y: acc.y + point.y }), { x: 0, y: 0 });

  return {
    x: sum.x / points.length,
    y: sum.y / points.length,
  };
};

// Apply transformation to a single point
export const applyTransformationToPoint = (point: Point, rotation: number, translation: Point): Point => {
  const cos = Math.cos(rotation);
  const sin = Math.sin(rotation);

  return {
    x: cos * point.x - sin * point.y + translation.x,
    y: sin * point.x + cos * point.y + translation.y,
  };
};

// Apply transformation to an array of points
export const applyTransformation = (points: Point[], rotation: number, translation: Point): Point[] => {
  return points.map((point) => applyTransformationToPoint(point, rotation, translation));
};

// Calculate mean squared error
export const calculateError = (points1: Point[], points2: Point[]): number => {
  if (points1.length !== points2.length) return Number.POSITIVE_INFINITY;
  if (points1.length === 0) return 0;

  let sum = 0;
  for (let i = 0; i < points1.length; i++) {
    sum += Math.pow(points1[i].x - points2[i].x, 2) + Math.pow(points1[i].y - points2[i].y, 2);
  }

  return sum / points1.length;
};


---
../../../icp/ts_impl.txt
---


---
